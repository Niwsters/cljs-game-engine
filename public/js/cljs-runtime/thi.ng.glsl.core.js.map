{"version":3,"sources":["thi/ng/glsl/core.cljc"],"mappings":";AAKA,iCAAA,jCAAOA,0EACJC;AADH,AAEE,kCAAA,3BAACC,uBACAD,mBACA,WAAAE;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAAME;QAAN,AAAAD,4CAAAD,WAAA,IAAA,/DAAQG;QAAR,AAAAF,4CAAAD,WAAA,IAAA,/DAAUI;AAAV,AACE,GACE,6CAAA,7CAACC,iDAAMF;AAAU,QAAA,gDAAQC;;AAD3B,GAEE,uBAAA,iFAAA,xGAACE,gIAAaF;AAAG,uDAAA,HAAKD;;AAFxB,AAGmBD;;;;;;AAExB,+BAAA,/BAAOK,sEACJV;AADH,AAEE,IAAMA,uFAAQA,/BACA,AAACD,vBACD,2DAAA,YAAA,vEAACE,vBACD,kGAAA,gEAAA,lKAACA;AAHf,AAIE,GAAI,6CAAA,7CAACO,iDAAK,AAACG,gBAAMX;AACf,QAAA,aAAA,RAAUA;;AACVA;;;AAEN,qCAAA,rCAAOY,kFACJZ;AADH,AACQ,kCAAA,SAAA,pCAACC,uBAAYD;;AAErB,0BAAA,1BAAMa,4DACHb;AADH,AAEE,IAAMA,+EAAQA,vBACA,2BAAA,SAAA,pCAACC,vBACD,+DAAA,mBAAA,lFAACA,vBACD,6GAAA,OAAA,pHAACA;AAHf,+KAIO,2DAAA,3DAACa,mDAAUd,5HACX,AAACe,4CAAIL,xGACL,AAACM,8CAAMC,xFACP,OAACL;;AAEV,2BAAA,3BAAeM;AAGf;;;;;qCAAA,rCAAMC,kFAIHnB;AAJH,AAKE,IAAAoB,qBAAW,AAACT,gBAAM,AAACW,iBAAOJ,yBAAQlB;AAAlC,AAAA,oBAAAoB;AAAA,QAAAA,JAASC;AAAT,AACE,IAAME,UAAO,8CAAA,9CAACnB,4CAAIiB;IACZG,OAAO,8CAAA,9CAACpB,4CAAIiB;IACZI,OAAO,AAACC,cAAI,AAACC,+CAAOC,cAAI,sGAAA,tGAACd,mDAAU,8CAAA,9CAACV,4CAAIiB;AAF9C,AAAA,kDAAA,0EAAA,oEAAA,5EAGgBE,uEACAC,mEACAC;;AANlB;;;AAgCF,AAAA,+BAAA,uCAAAI,tEAAOE;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,2DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,2DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,6DAAA,7DAAOD,wEACHE;AADJ,AACU,OAACC,2DAAY,AAACC,oCAAWF;;;AADnC,CAAA,6DAAA,7DAAOF,wEAEHK,EAAEC;AAFN,AAGK,OAACC,+CACA,WAAKF,MAAE9B;AAAP,AAAU,OAAC4B,2DAAY,AAACK,mCAAWH,MAAEC,KAAK/B,GAAGA;GAC7C8B,EAAE,AAAA,mFAAOC;;;AALf,CAAA,uDAAA,vDAAON;;AAAP,AAOA,4BAAA,5BAAMS,gEACHP;AADH,AAEE,GAAI,AAACL,cAAI,AAAA,mFAAOK;qQACTA,3DACA,AAACC,tCACD,AAACO,jGACD,6CAAA,7CAACC,nEACD,OAAC1B,8CAAMC;;AACZ,OAAA,kFAAMgB;;;AAEV,mCAAA,nCAAMU,8EACHC,KAAK5C;AADR,AAAA,kDAAA,0DAAA,LACoB4C,yDAAU5C","names":["thi.ng.glsl.core/minify-floats","src","clojure.string/replace","p__15909","vec__15910","cljs.core.nth","o","d","f","cljs.core._EQ_","cljs.core/every?","thi.ng.glsl.core/minify-line","cljs.core/first","thi.ng.glsl.core/clean-line-breaks","thi.ng.glsl.core/minify","clojure.string.split","cljs.core.map","cljs.core.apply","cljs.core/str","thi.ng.glsl.core/re-meta","thi.ng.glsl.core/extract-glsl-meta","temp__5802__auto__","m","cljs.core/re-seq","return","name","args","cljs.core/vec","cljs.core.filter","cljs.core/seq","var_args","G__15963","thi.ng.glsl.core/build-graph","js/Error","spec","thi.ng.glsl.core.build_graph","com.stuartsierra.dependency/graph","g","curr","cljs.core.reduce","com.stuartsierra.dependency/depend","thi.ng.glsl.core/assemble","com.stuartsierra.dependency/topo-sort","cljs.core.mapv","thi.ng.glsl.core/glsl-spec-plain","deps"],"sourcesContent":["(ns thi.ng.glsl.core\n  (:require\n   [clojure.string :as str]\n   [com.stuartsierra.dependency :as dep]))\n\n(defn- minify-floats\n  [src]\n  (str/replace\n   src #\"(\\d+)\\.(\\d+)\"\n   (fn [[o d f]]\n     (cond\n       (= \"0\" d)        (str \\. f)\n       (every? #{\\0} f) (str d \\.)\n       :else            o))))\n\n(defn- minify-line\n  [src]\n  (let [src (-> src\n                (minify-floats)\n                (str/replace #\"\\s{2,}|\\t\" \"\")\n                (str/replace #\"\\s*(\\{|\\}|\\=|\\*|\\,|\\+|/|\\>|\\<|\\&|\\||\\[|\\]|\\(|\\)|\\-|\\!|\\;)\\s*\" \"$1\"))]\n    (if (= \\# (first src))\n      (str \"\\n\" src \"\\n\")\n      src)))\n\n(defn- clean-line-breaks\n  [src] (str/replace src #\"\\n{2,}\" \"\\n\"))\n\n(defn minify\n  [src]\n  (let [src (-> src\n                (str/replace #\"//.*\" \"\")\n                (str/replace #\"/\\*[\\s\\S]*?\\*/\" \"\")\n                (str/replace #\"^\\n+\" \"\"))]\n    (->> (str/split src #\"\\n\")\n         (map minify-line)\n         (apply str)\n         (clean-line-breaks))))\n\n(def ^:private re-meta\n  #\"((((highp|mediump|lowp)\\s+)?(void|bool|float|int|(b|i)?vec\\d|mat\\d))\\s+([\\w_]+)\\s*\\(([A-Za-z0-9_, ]*)\\)\\s*\\{)\")\n\n(defn extract-glsl-meta\n  \"Attempts to extract function name, return type and args from given\n  GLSL source string. If successful, returns map w/ these\n  keys: :glsl-name :glsl-return :glsl-args\"\n  [src]\n  (if-let [m (first (re-seq re-meta src))]\n    (let [return (nth m 2)\n          name   (nth m 7)\n          args   (vec (filter seq (str/split (nth m 8) #\",\\s*\")))]\n      {:glsl-return return\n       :glsl-name   name\n       :glsl-args   args})))\n\n#?(:clj\n   (defmacro minified\n     [src] `~(minify src)))\n\n#?(:clj\n   (defmacro glsl-spec\n     [deps src] `{:deps ~deps :src (minified ~src)}))\n\n#?(:clj\n   (defmacro glsl-file-spec\n     [deps path] `{:deps ~deps :src (minified ~(slurp path))}))\n\n#?(:clj\n   (defmacro defglsl\n     [name deps src]\n     `(do (def ~name (glsl-spec ~deps ~src))\n          (alter-meta! (var ~name) merge ~(extract-glsl-meta src)))))\n\n#?(:clj\n   (defmacro defglsl-file\n     [name deps path]\n     `(do (def ~name (glsl-file-spec ~deps ~path))\n          (alter-meta! (var ~name) merge ~(extract-glsl-meta (get name :src))))))\n\n(defn- build-graph\n  ([spec] (build-graph (dep/graph) spec))\n  ([g curr]\n     (reduce\n      (fn [g d] (build-graph (dep/depend g curr d) d))\n      g (:deps curr))))\n\n(defn assemble\n  [spec]\n  (if (seq (:deps spec))\n    (->> spec\n         (build-graph)\n         (dep/topo-sort)\n         (mapv :src)\n         (apply str))\n    (:src spec)))\n\n(defn glsl-spec-plain\n  [deps src] {:deps deps :src src})\n"]}